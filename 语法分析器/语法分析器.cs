//System命名空间，提供基础功能
using System;
//泛型集合命名空间，用于存储Token和AST节点列表
using System.Collections.Generic;
//词法
using CnToCs.词法分析器;
//AST
using CnToCs.抽象语法树;
// 定义语法分析器相关的命名空间
namespace CnToCs.语法分析器
{
    public class 语法分析器
    {
        private List<词法单元> 词法单元列表;
        private int 当前位置;
        private List<string> 已解析的接口列表;
        private List<string> 收集的注释列表;
        private Dictionary<string, List<string>> 节点注释映射;
        private Dictionary<string, List<string>> 属性注释映射;
        private Dictionary<string, List<string>> 方法注释映射;
        
        public 语法分析器(List<词法单元> 词法单元列表)
        {
            this.词法单元列表 = 词法单元列表;
            this.当前位置 = 0;
            this.已解析的接口列表 = new List<string>();
            this.收集的注释列表 = new List<string>();
            this.节点注释映射 = new Dictionary<string, List<string>>();
            this.属性注释映射 = new Dictionary<string, List<string>>();
            this.方法注释映射 = new Dictionary<string, List<string>>();
        }

        public 语法树节点 解析()
        {
            //储存所有顶层AST节点
            var 节点列表 = new List<语法树节点>();
            //遍历所有Token，解析为Ast节点

            //判断当前位置是否小于词法单元列表中的元素数量
            while (this.当前位置 < this.词法单元列表.Count)
            {
                //如果当前token是接口关键字，解析接口
                if(当前词法单元.类型 == 词法单元类型.接口)
                {
                    节点列表.Add(解析接口());
                }
                else if(当前词法单元.类型 == 词法单元类型.类)
                {
                    节点列表.Add(解析类());
                }
                else if(当前词法单元.类型 == 词法单元类型.单行注释 || 当前词法单元.类型 == 词法单元类型.多行注释)
                {
                    // 收集注释，但不跳过，让后续的解析方法处理
                    this.收集的注释列表.Add(当前词法单元.值);
                    this.当前位置++;
                }
                else
                {
                    // 跳过不支持的语法结构
                    Console.WriteLine($"警告: 跳过不支持的语法结构: {当前词法单元.值}");
                    this.当前位置++;
                }
            }
            //返回根节点，以及所有的子节点
            return new 根节点(节点列表);
        }
        private 词法单元 当前词法单元
        {
            get
            {
                if (this.当前位置 < this.词法单元列表.Count)
                    return this.词法单元列表[this.当前位置];
                throw new Exception("已到达token流末尾");
            }
        }
        private 词法单元 匹配语法(词法单元类型 类型)
        {
            if (当前词法单元.类型 != 类型)
            {
                throw new Exception($"期望得到 D类型值为： {类型}，但得到 {当前词法单元.类型}");
            }
            var 词法单元 = 当前词法单元;
            this.当前位置++;
            return 词法单元;
        }
        private 接口节点 解析接口()
        {
            // 收集接口前的注释
            var 接口注释 = new List<string>();
            
            // 先检查收集的注释列表中是否有注释
            if (this.收集的注释列表.Count > 0)
            {
                接口注释.AddRange(this.收集的注释列表);
                this.收集的注释列表.Clear();
            }
            
            // 跳过注释，找到接口关键字
            while (this.当前位置 < this.词法单元列表.Count &&
                  (当前词法单元.类型 == 词法单元类型.单行注释 || 当前词法单元.类型 == 词法单元类型.多行注释))
            {
                接口注释.Add(当前词法单元.值);
                this.当前位置++;
            }
            
            匹配语法(词法单元类型.接口);
            string 名称 = 匹配语法(词法单元类型.标识符).值;
            
            // 将接口名称添加到已解析的接口列表中
            this.已解析的接口列表.Add(名称);
            
            // 保存接口注释
            if (接口注释.Count > 0)
            {
                this.节点注释映射[名称] = 接口注释;
                Console.WriteLine($"为接口 {名称} 添加了 {接口注释.Count} 个注释");
            }
            
            // 检查是否有继承
            var 基接口列表 = new List<string>();
            if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.冒号)
            {
                this.当前位置++;
                基接口列表.Add(匹配语法(词法单元类型.标识符).值);
                
                // 检查是否有多个继承（多重继承）
                while (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.逗号)
                {
                    this.当前位置++; // 跳过逗号
                    if (this.当前位置 < this.词法单元列表.Count)
                    {
                        // 保存额外的接口名称
                        基接口列表.Add(匹配语法(词法单元类型.标识符).值);
                    }
                }
            }
            
            匹配语法(词法单元类型.左大括号);
            
            //属性和方法
            var 属性列表 = new List<属性节点>();
            var 方法列表 = new List<方法节点>();
            //解析所有的属性和方法，一直到遇到右大括号
            while (当前词法单元.类型 != 词法单元类型.右大括号)
            {
                // 处理注释，但不跳过，让后续的解析方法处理
                if(当前词法单元.类型 == 词法单元类型.单行注释 || 当前词法单元.类型 == 词法单元类型.多行注释)
                {
                    this.收集的注释列表.Add(当前词法单元.值);
                    this.当前位置++;
                    continue;
                }
                
                if(当前词法单元.类型 == 词法单元类型.方法 || 当前词法单元.类型 == 词法单元类型.虚方法||当前词法单元.类型 == 词法单元类型.重写方法||当前词法单元.类型 == 词法单元类型.抽象方法)
                {
                    var 方法节点 = 解析方法(名称);
                    if (方法节点 != null)
                    {
                        // 接口中的方法不需要特殊处理，保持原有标记
                        // 这样可以区分接口中的虚方法和普通方法
                        方法列表.Add(方法节点);
                    }
                }
                else if(当前词法单元.类型==词法单元类型.公开||
                        当前词法单元.类型==词法单元类型.私有||
                        当前词法单元.类型==词法单元类型.保护||
                        当前词法单元.类型==词法单元类型.可为空||
                        当前词法单元.类型==词法单元类型.标识符||
                        当前词法单元.类型==词法单元类型.静态
                )
                {
                    try
                    {
                        属性列表.Add(解析属性(名称));
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"警告: 解析属性失败，跳过: {ex.Message}");
                        // 跳过直到找到分号或右大括号
                        while (this.当前位置 < this.词法单元列表.Count &&
                               当前词法单元.类型 != 词法单元类型.分号 &&
                               当前词法单元.类型 != 词法单元类型.右大括号)
                        {
                            this.当前位置++;
                        }
                        // 如果找到分号，也跳过它
                        if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.分号)
                        {
                            this.当前位置++;
                        }
                    }
                }else if (当前词法单元.类型 == 词法单元类型.分号)
                {
                    //跳过
                    this.当前位置++;
                }
                else
                {
                    // 跳过不支持的语法结构
                    Console.WriteLine($"警告: 跳过不支持的接口语法: {当前词法单元.值}");
                    this.当前位置++;
                }
            }
            匹配语法(词法单元类型.右大括号);
            //返回接口节点
            return new 接口节点(名称, 属性列表, 基接口列表,方法列表);
        }
        //与解析接口相识
        private 类节点 解析类()
        {
            // 收集类前的注释
            var 类注释 = new List<string>();
            
            // 先检查收集的注释列表中是否有注释
            if (this.收集的注释列表.Count > 0)
            {
                类注释.AddRange(this.收集的注释列表);
                this.收集的注释列表.Clear();
            }
            
            // 跳过注释，找到类关键字
            while (this.当前位置 < this.词法单元列表.Count &&
                  (当前词法单元.类型 == 词法单元类型.单行注释 || 当前词法单元.类型 == 词法单元类型.多行注释))
            {
                类注释.Add(当前词法单元.值);
                this.当前位置++;
            }
            
            匹配语法(词法单元类型.类);
            var 名称 = 匹配语法(词法单元类型.标识符).值;
            
            // 保存类注释
            if (类注释.Count > 0)
            {
                this.节点注释映射[名称] = 类注释;
                Console.WriteLine($"为类 {名称} 添加了 {类注释.Count} 个注释");
            }
            
            // 检查是否有继承
            string? 基类名称 = null;
            var 基接口列表 = new List<string>();
            if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.冒号)
            {
                this.当前位置++;
                string 第一个继承名称 = 匹配语法(词法单元类型.标识符).值;
                
                // 检查第一个继承的名称是否是已知的接口
                if (this.已解析的接口列表.Contains(第一个继承名称))
                {
                    // 第一个是接口，添加到基接口列表
                    基接口列表.Add(第一个继承名称);
                }
                else
                {
                    // 第一个是基类
                    基类名称 = 第一个继承名称;
                }
                
                // 检查是否有多个继承（多重继承）
                while (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.逗号)
                {
                    this.当前位置++; // 跳过逗号
                    if (this.当前位置 < this.词法单元列表.Count)
                    {
                        // 保存额外的接口名称
                        基接口列表.Add(匹配语法(词法单元类型.标识符).值);
                    }
                }
            }
            
            匹配语法(词法单元类型.左大括号);
            
            //属性和方法
            var 属性列表 = new List<属性节点>();
            var 方法列表 = new List<方法节点>();
            构造函数节点? 构造函数 = null;

            while (当前词法单元.类型 != 词法单元类型.右大括号)
            {
                // 处理注释，但不跳过，让后续的解析方法处理
                if(当前词法单元.类型 == 词法单元类型.单行注释 || 当前词法单元.类型 == 词法单元类型.多行注释)
                {
                    this.收集的注释列表.Add(当前词法单元.值);
                    this.当前位置++;
                    continue;
                }
                
                if(当前词法单元.类型 == 词法单元类型.构造函数)
                {
                    构造函数 = 解析构造函数();
                }
                else if(当前词法单元.类型 == 词法单元类型.方法|| 当前词法单元.类型 == 词法单元类型.虚方法||当前词法单元.类型 == 词法单元类型.重写方法||当前词法单元.类型 == 词法单元类型.抽象方法)
                {
                    方法列表.Add(解析方法(名称));
                }
                else if(当前词法单元.类型 == 词法单元类型.公开 ||
                        当前词法单元.类型 == 词法单元类型.私有 ||
                        当前词法单元.类型 == 词法单元类型.保护 ||
                        当前词法单元.类型 == 词法单元类型.静态 ||
                        当前词法单元.类型 == 词法单元类型.只读 ||
                        当前词法单元.类型 == 词法单元类型.标识符)
                {
                    try
                    {
                        属性列表.Add(解析属性(名称));
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"警告: 解析属性失败，跳过: {ex.Message}");
                        // 跳过直到找到分号或右大括号
                        while (this.当前位置 < this.词法单元列表.Count &&
                               当前词法单元.类型 != 词法单元类型.分号 &&
                               当前词法单元.类型 != 词法单元类型.右大括号)
                        {
                            this.当前位置++;
                        }
                        // 如果找到分号，也跳过它
                        if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.分号)
                        {
                            this.当前位置++;
                        }
                    }
                }
                else if (当前词法单元.类型 == 词法单元类型.分号)
                {
                    //跳过
                    this.当前位置++;
                }
                else
                {
                    // 跳过不支持的语法结构
                    Console.WriteLine($"警告: 跳过不支持的类语法: {当前词法单元.值}");
                    this.当前位置++;
                }
            }
            
            匹配语法(词法单元类型.右大括号);
            // 返回类节点
            return new 类节点(名称, 基类名称, 基接口列表, 属性列表, 方法列表, 构造函数);
        }
        private 构造函数节点 解析构造函数()
        {
            //处理参数
            匹配语法(词法单元类型.构造函数);
            匹配语法(词法单元类型.左圆括号);
            var 参数列表 = new List<参数节点>();
            while (当前词法单元.类型 != 词法单元类型.右圆括号)
            {
                bool 是否可为空 = false;
                string 参数名称 = 匹配语法(词法单元类型.标识符).值;
                匹配语法(词法单元类型.冒号);
                类型节点 参数类型 = 解析类型();
                if(当前词法单元.类型 == 词法单元类型.可为空)
                {
                    是否可为空=true;
                    匹配语法(词法单元类型.可为空);
                }
                
                参数列表.Add(new 参数节点(参数名称,参数类型,是否可为空));
                if (当前词法单元.类型 == 词法单元类型.逗号)
                {
                    //跳过逗号
                    this.当前位置++;
                }
                else
                {
                    break;
                }
            }
            匹配语法(词法单元类型.右圆括号);

            // 检查是否有基类构造函数调用
            string? 基类构造函数调用 = null;
            if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.冒号)
            {
                this.当前位置++; // 跳过冒号
                if (this.当前位置 < this.词法单元列表.Count)
                {
                    基类构造函数调用 = 匹配语法(词法单元类型.标识符).值;
                    
                    if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.左圆括号)
                    {
                        // 跳过基类构造函数参数列表
                        int 括号计数 = 1;
                        this.当前位置++;
                        while (括号计数 > 0 && this.当前位置 < this.词法单元列表.Count)
                        {
                            if (当前词法单元.类型 == 词法单元类型.左圆括号) {括号计数++;}
                            else if (当前词法单元.类型 == 词法单元类型.右圆括号) {括号计数--;}
                            this.当前位置++;
                        }
                    }
                }
            }

            // 解析构造函数体
            方法体节点? 方法体 = null;
            if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.左大括号)
            {
                方法体 = 解析方法体();
            }
            
            return new 构造函数节点(参数列表, 方法体, 基类构造函数调用);
        }
        private 类型节点 返回类型(string 字符串)
        {
            this.当前位置++;
            return new 类型节点(字符串);
        }
        private 类型节点 解析类型()
        {
            switch (当前词法单元.类型)
            {
                case 词法单元类型.整数:

                return 返回类型("int");
                
                case 词法单元类型.字符串:

                return 返回类型("string");

                case 词法单元类型.小数:

                return 返回类型("double");

                case 词法单元类型.布尔值:

                return 返回类型("bool");

                case 词法单元类型.对象:

                return 返回类型("object");

                case 词法单元类型.无返回值:

                return 返回类型("void");

                default:
                break;
            }
            string?修饰符 = null;
            if (当前词法单元.类型 == 词法单元类型.引用)
            {
                修饰符 = 匹配语法(词法单元类型.引用).值;
            }
            string 类型名称 = 匹配语法(词法单元类型.标识符).值;
            bool 是否为泛型 = false;
            List<类型节点> 泛型参数列表 = new List<类型节点>();

            if (this.当前位置 < this.词法单元列表.Count&&当前词法单元.类型 == 词法单元类型.左尖括号)
            {
                是否为泛型=true;
                while (当前词法单元.类型!=词法单元类型.右尖括号)
            {
                类型节点 参数类型 = 解析类型();
                泛型参数列表.Add(参数类型);
                if (当前词法单元.类型 == 词法单元类型.逗号)
                {
                    this.当前位置++;
                }
                else
                {
                    break;
                }
            }
                匹配语法(词法单元类型.右尖括号);
            }
            return new 类型节点(类型名称,是否为泛型,修饰符,泛型参数列表);
            
        }
        private 方法节点 解析方法(string 类名)
        {
            bool 是否为虚方法 = false;
            bool 是否为抽象方法 = false;
            bool 是否为重写方法 = false;
            
            // 收集方法前的注释
            var 方法注释 = new List<string>();
            
            // 先检查收集的注释列表中是否有注释
            if (this.收集的注释列表.Count > 0)
            {
                方法注释.AddRange(this.收集的注释列表);
                this.收集的注释列表.Clear();
            }
            
            // 跳过注释，找到方法关键字
            while (this.当前位置 < this.词法单元列表.Count &&
                  (当前词法单元.类型 == 词法单元类型.单行注释 || 当前词法单元.类型 == 词法单元类型.多行注释))
            {
                方法注释.Add(当前词法单元.值);
                this.当前位置++;
            }
            
            //访问属性
            if (当前词法单元.类型 == 词法单元类型.公开)
            {
                匹配语法(词法单元类型.公开);
            }
            else if (当前词法单元.类型 == 词法单元类型.私有)
            {
               匹配语法(词法单元类型.私有);
            }
            else if (当前词法单元.类型 == 词法单元类型.静态)
            {
                匹配语法(词法单元类型.静态);
            }

            //声明方法类型：虚方法，重写方法，抽象方法，普通方法
            if (当前词法单元.类型 == 词法单元类型.重写方法)
            {
                是否为重写方法 = true;
                匹配语法(词法单元类型.重写方法);
            }
            else if (当前词法单元.类型 == 词法单元类型.虚方法)
            {
                是否为虚方法 = true;
                匹配语法(词法单元类型.虚方法);
            }
            else if(当前词法单元.类型 == 词法单元类型.抽象方法)
            {
                是否为抽象方法 = true;
                匹配语法(词法单元类型.抽象方法);
            }
            else
            {
                匹配语法(词法单元类型.方法);
            }
            string 方法名 = 匹配语法(词法单元类型.标识符).值;
            
            // 保存方法注释
            if (方法注释.Count > 0)
            {
                string 方法键 = $"{类名}.{方法名}";
                this.方法注释映射[方法键] = 方法注释;
                Console.WriteLine($"为方法 {方法键} 添加了 {方法注释.Count} 个注释");
            }
            
            // 检查方法名后面是冒号还是左圆括号
            // 如果是左圆括号，则是接口方法声明，需要检查是否有返回类型
            类型节点 返回值类型;
            var 参数列表 = new List<参数节点>();
            
            if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.左圆括号)
            {
                // 接口方法声明，先解析参数列表
                this.当前位置++; // 跳过左圆括号
                
                //解析参数
                while (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 != 词法单元类型.右圆括号)
                {
                    string 参数名称;
                    if (当前词法单元.类型 == 词法单元类型.标识符 || 当前词法单元.类型 == 词法单元类型.新)
                    {
                        if (当前词法单元.类型 == 词法单元类型.新)
                        {
                            // 处理"新X"这样的参数名，"新"是关键字，但这里用作参数名前缀
                            匹配语法(词法单元类型.新);
                            参数名称 = "新" + 匹配语法(词法单元类型.标识符).值;
                        }
                        else
                        {
                            参数名称 = 匹配语法(词法单元类型.标识符).值;
                        }
                    }
                    else
                    {
                        // 跳过不支持的语法结构
                        Console.WriteLine($"警告: 跳过不支持的参数语法: {当前词法单元.值}");
                        // 跳过当前token，继续尝试解析
                        this.当前位置++;
                        continue;
                    }
                    
                    // 检查是否有引用参数
                    bool 是否为引用参数 = false;
                    if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.引用)
                    {
                        是否为引用参数 = true;
                        匹配语法(词法单元类型.引用);
                    }
                    
                    匹配语法(词法单元类型.冒号);
                    类型节点 参数类型 = 解析类型();
                    
                    // 检查是否为可空参数
                    bool 是否为可空 = false;
                    if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.可为空)
                    {
                        是否为可空 = true;
                        匹配语法(词法单元类型.可为空);
                    }
                      
                    参数列表.Add(new 参数节点(参数名称, 参数类型, 是否为可空));
                    if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.逗号)
                    {
                        this.当前位置++;
                    }
                }
                匹配语法(词法单元类型.右圆括号);
                
                // 检查是否有返回类型
                if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.冒号)
                {
                    匹配语法(词法单元类型.冒号);
                    返回值类型 = 解析类型();
                }
                else
                {
                    // 没有返回类型，默认返回类型为void
                    返回值类型 = new 类型节点("void");
                }
            }
            else
            {
                // 普通方法声明，先解析返回类型
                匹配语法(词法单元类型.冒号);
                返回值类型 = 解析类型();
                
                // 检查是否有参数
                if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.左圆括号)
                {
                    this.当前位置++; // 跳过左圆括号
                    
                    //解析参数
                    while (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 != 词法单元类型.右圆括号)
                    {
                        string 参数名称;
                        if (当前词法单元.类型 == 词法单元类型.标识符 || 当前词法单元.类型 == 词法单元类型.新)
                        {
                            if (当前词法单元.类型 == 词法单元类型.新)
                            {
                                // 处理"新X"这样的参数名，"新"是关键字，但这里用作参数名前缀
                                匹配语法(词法单元类型.新);
                                参数名称 = "新" + 匹配语法(词法单元类型.标识符).值;
                            }
                            else
                            {
                                参数名称 = 匹配语法(词法单元类型.标识符).值;
                            }
                        }
                        else
                        {
                            // 跳过不支持的语法结构
                            Console.WriteLine($"警告: 跳过不支持的参数语法: {当前词法单元.值}");
                            // 跳过当前token，继续尝试解析
                            this.当前位置++;
                            continue;
                        }
                        
                        // 检查是否有引用参数
                        bool 是否为引用参数 = false;
                        if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.引用)
                        {
                            是否为引用参数 = true;
                            匹配语法(词法单元类型.引用);
                        }
                        
                        匹配语法(词法单元类型.冒号);
                        类型节点 参数类型 = 解析类型();
                        
                        // 检查是否为可空参数
                        bool 是否为可空 = false;
                        if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.可为空)
                        {
                            是否为可空 = true;
                            匹配语法(词法单元类型.可为空);
                        }
                          
                        参数列表.Add(new 参数节点(参数名称, 参数类型, 是否为可空));
                        if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.逗号)
                        {
                            this.当前位置++;
                        }
                    }
                    匹配语法(词法单元类型.右圆括号);
                }
            }

            // 解析方法体
            方法体节点? 方法体 = null;
            if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.左大括号)
            {
                方法体 = 解析方法体();
            }
            else if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.冒号)
            {
                // 可能是方法返回类型在参数列表之后的情况
                // 这种情况下，我们需要跳过冒号和返回类型，然后查找方法体
                this.当前位置++; // 跳过冒号
                返回值类型 = 解析类型();
                
                // 检查是否有方法体
                if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.左大括号)
                {
                    方法体 = 解析方法体();
                }
            }
           
            return new 方法节点(方法名,返回值类型,参数列表,是否为虚方法,是否为抽象方法,是否为重写方法,方法体);
        }
        private 属性节点 解析属性(string 类名)
        {
            string 访问修饰符 = "public";
            bool 是否为可空 = false;
            
            // 收集属性前的注释
            var 属性注释 = new List<string>();
            
            // 先检查收集的注释列表中是否有注释
            if (this.收集的注释列表.Count > 0)
            {
                属性注释.AddRange(this.收集的注释列表);
                this.收集的注释列表.Clear();
            }
            
            // 跳过注释，找到属性关键字
            while (this.当前位置 < this.词法单元列表.Count &&
                  (当前词法单元.类型 == 词法单元类型.单行注释 || 当前词法单元.类型 == 词法单元类型.多行注释))
            {
                属性注释.Add(当前词法单元.值);
                this.当前位置++;
            }
            
            // 检查访问修饰符
            if (当前词法单元.类型 == 词法单元类型.公开)
            {
                访问修饰符 = "public";
                this.当前位置++;
            }
            else if (当前词法单元.类型 == 词法单元类型.私有)
            {
                访问修饰符 = "private";
                this.当前位置++;
            }
            else if (当前词法单元.类型 == 词法单元类型.保护)
            {
                访问修饰符 = "protected";
                this.当前位置++;
            }
            else if (当前词法单元.类型 == 词法单元类型.静态)
            {
                访问修饰符 = "static";
                this.当前位置++;
            }
            else if (当前词法单元.类型 == 词法单元类型.只读)
            {
                访问修饰符 = "readonly";
                this.当前位置++;
            }
            
            // 检查是否为可空属性
            if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.可为空)
            {
                是否为可空 = true;
                this.当前位置++;
            }

            // 匹配属性名
            string 属性名 = 匹配语法(词法单元类型.标识符).值;
            
            // 保存属性注释
            if (属性注释.Count > 0)
            {
                string 属性键 = $"{类名}.{属性名}";
                this.属性注释映射[属性键] = 属性注释;
                Console.WriteLine($"为属性 {属性键} 添加了 {属性注释.Count} 个注释");
            }
            
            // 检查是否是方法声明（后面跟着左圆括号）
            if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.左圆括号)
            {
                throw new Exception($"属性声明：发现可能是方法声明: {属性名}");
            }
            
            // 匹配冒号
            匹配语法(词法单元类型.冒号);

            // 解析属性类型
            类型节点 @类型 = 解析类型();
            
            // 检查是否有初始化值（等号）
            属性初始化值节点? 初始化值 = null;
            if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.等号)
            {
                this.当前位置++; // 跳过等号
                初始化值 = new 属性初始化值节点(解析表达式());
            }
            
            // 检查是否有分号
            if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.分号)
            {
                this.当前位置++;
            }
            else
            {
                throw new Exception($"属性声明后期望分号，但得到: {当前词法单元.值}");
            }
 
            // 返回属性节点
            return new 属性节点(属性名, @类型, 是否为可空, 访问修饰符, 初始化值);
        }
        
        // 解析表达式
        private 表达式节点 解析表达式()
        {
            // 简单实现：只处理字面量和标识符
            if (this.当前位置 >= this.词法单元列表.Count)
                throw new Exception("表达式不完整");
                
            if (当前词法单元.类型 == 词法单元类型.字符串字面量)
            {
                var 值 = 匹配语法(词法单元类型.字符串字面量).值;
                var 左表达式 = new 字面量表达式节点(值, "string");
                
                // 检查是否有字符串拼接
                return 解析字符串拼接表达式(左表达式);
            }
            else if (当前词法单元.类型 == 词法单元类型.数字字面量)
            {
                var 值 = 匹配语法(词法单元类型.数字字面量).值;
                var 左表达式 = new 字面量表达式节点(值, "double");
                
                // 检查是否有二元运算
                return 解析二元运算表达式(左表达式);
            }
            else if (当前词法单元.类型 == 词法单元类型.标识符)
            {
                var 名称 = 匹配语法(词法单元类型.标识符).值;
                表达式节点 左表达式;
                
                // 检查是否是方法调用
                if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.左圆括号)
                {
                    左表达式 = 解析方法调用表达式(名称);
                }
                // 检查是否是属性访问
                else if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.点号)
                {
                    左表达式 = 解析属性访问表达式(名称);
                }
                else
                {
                    左表达式 = new 标识符表达式节点(名称);
                }
                
                // 检查是否有字符串拼接或二元运算
                if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.加号)
                {
                    return 解析字符串拼接表达式(左表达式);
                }
                else if (this.当前位置 < this.词法单元列表.Count &&
                        (当前词法单元.类型 == 词法单元类型.减号 ||
                         当前词法单元.类型 == 词法单元类型.乘号 ||
                         当前词法单元.类型 == 词法单元类型.除号 ||
                         当前词法单元.类型 == 词法单元类型.双等号 ||
                         当前词法单元.类型 == 词法单元类型.不等号 ||
                         当前词法单元.类型 == 词法单元类型.逻辑与 ||
                         当前词法单元.类型 == 词法单元类型.逻辑或))
                {
                    return 解析二元运算表达式(左表达式);
                }
                
                return 左表达式;
            }
            else if (当前词法单元.类型 == 词法单元类型.左圆括号)
            {
                // 处理括号表达式
                匹配语法(词法单元类型.左圆括号);
                var 表达式 = 解析表达式();
                匹配语法(词法单元类型.右圆括号);
                
                // 检查括号表达式后面是否有运算符
                if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.加号)
                {
                    return 解析字符串拼接表达式(表达式);
                }
                else if (this.当前位置 < this.词法单元列表.Count &&
                        (当前词法单元.类型 == 词法单元类型.减号 ||
                         当前词法单元.类型 == 词法单元类型.乘号 ||
                         当前词法单元.类型 == 词法单元类型.除号 ||
                         当前词法单元.类型 == 词法单元类型.双等号 ||
                         当前词法单元.类型 == 词法单元类型.不等号 ||
                         当前词法单元.类型 == 词法单元类型.逻辑与 ||
                         当前词法单元.类型 == 词法单元类型.逻辑或))
                {
                    return 解析二元运算表达式(表达式);
                }
                
                return 表达式;
            }
            else if (当前词法单元.类型 == 词法单元类型.新)
            {
                return 解析对象创建表达式();
            }
            else if (当前词法单元.类型 == 词法单元类型.空)
            {
                匹配语法(词法单元类型.空);
                return new 字面量表达式节点("null", "null");
            }
            else if (当前词法单元.类型 == 词法单元类型.真)
            {
                匹配语法(词法单元类型.真);
                return new 字面量表达式节点("true", "bool");
            }
            else if (当前词法单元.类型 == 词法单元类型.假)
            {
                匹配语法(词法单元类型.假);
                return new 字面量表达式节点("false", "bool");
            }
            else
            {
                throw new Exception($"不支持的表达式类型: {当前词法单元.值}");
            }
        }
        
        // 解析字符串拼接表达式
        private 表达式节点 解析字符串拼接表达式(表达式节点 左操作数)
        {
            // 检查是否有加号运算符
            while (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.加号)
            {
                this.当前位置++; // 跳过加号
                
                // 解析右侧表达式
                var 右操作数 = 解析表达式();
                
                // 创建新的二元运算表达式节点作为新的左操作数，支持连续拼接
                左操作数 = new 二元运算表达式节点(左操作数, "+", 右操作数);
            }
            
            // 返回最终的拼接表达式
            return 左操作数;
        }
        
        // 解析二元运算表达式
        private 表达式节点 解析二元运算表达式(表达式节点? 左操作数 = null)
        {
            if (左操作数 == null)
            {
                左操作数 = 解析表达式();
            }
            
            // 检查是否有运算符
            if (this.当前位置 >= this.词法单元列表.Count)
                return 左操作数;
                
            var 运算符类型 = 当前词法单元.类型;
            string 运算符 = "";
            
            switch (运算符类型)
            {
                case 词法单元类型.减号:
                    运算符 = "-";
                    break;
                case 词法单元类型.乘号:
                    运算符 = "*";
                    break;
                case 词法单元类型.除号:
                    运算符 = "/";
                    break;
                case 词法单元类型.双等号:
                    运算符 = "==";
                    break;
                case 词法单元类型.不等号:
                    运算符 = "!=";
                    break;
                case 词法单元类型.逻辑与:
                    运算符 = "&&";
                    break;
                case 词法单元类型.逻辑或:
                    运算符 = "||";
                    break;
                default:
                    // 如果不是运算符，可能是字符串拼接，尝试解析
                    return 解析字符串拼接表达式(左操作数);
            }
            
            this.当前位置++; // 跳过运算符
            
            var 右操作数 = 解析表达式();
            
            // 检查是否还有更多的运算符，支持连续运算
            if (this.当前位置 < this.词法单元列表.Count)
            {
                var 下一个运算符类型 = 当前词法单元.类型;
                if (下一个运算符类型 == 词法单元类型.加号 ||
                    下一个运算符类型 == 词法单元类型.减号 ||
                    下一个运算符类型 == 词法单元类型.乘号 ||
                    下一个运算符类型 == 词法单元类型.除号 ||
                    下一个运算符类型 == 词法单元类型.双等号 ||
                    下一个运算符类型 == 词法单元类型.不等号 ||
                    下一个运算符类型 == 词法单元类型.逻辑与 ||
                    下一个运算符类型 == 词法单元类型.逻辑或)
                {
                    if (下一个运算符类型 == 词法单元类型.加号)
                    {
                        return 解析字符串拼接表达式(new 二元运算表达式节点(左操作数, 运算符, 右操作数));
                    }
                    else
                    {
                        return 解析二元运算表达式(new 二元运算表达式节点(左操作数, 运算符, 右操作数));
                    }
                }
            }
            
            return new 二元运算表达式节点(左操作数, 运算符, 右操作数);
        }
        
        // 解析方法调用表达式
        private 表达式节点 解析方法调用表达式(string 目标名称)
        {
            var 目标 = new 标识符表达式节点(目标名称);
            var 参数列表 = new List<表达式节点>();
            
            匹配语法(词法单元类型.左圆括号);
            
            // 解析参数列表
            while (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 != 词法单元类型.右圆括号)
            {
                var 参数 = 解析表达式();
                参数列表.Add(参数);
                
                if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.逗号)
                {
                    匹配语法(词法单元类型.逗号);
                }
            }
            
            匹配语法(词法单元类型.右圆括号);
            
            return new 方法调用表达式节点(目标, 参数列表);
        }
        
        // 解析属性访问表达式
        private 表达式节点 解析属性访问表达式(string 目标名称)
        {
            var 目标 = new 标识符表达式节点(目标名称);
            
            匹配语法(词法单元类型.点号);
            
            if (this.当前位置 >= this.词法单元列表.Count)
                throw new Exception("属性访问表达式不完整");
                
            var 属性名 = 匹配语法(词法单元类型.标识符).值;
            
            // 检查是否是方法调用
            if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.左圆括号)
            {
                return 解析方法调用表达式($"{目标名称}.{属性名}");
            }
            
            // 返回属性访问表达式
            return new 属性访问表达式节点(目标, 属性名);
        }
        
        // 解析对象创建表达式
        private 表达式节点 解析对象创建表达式()
        {
            匹配语法(词法单元类型.新);
            
            if (this.当前位置 >= this.词法单元列表.Count)
                throw new Exception("对象创建表达式不完整");
                
            var 类型名 = 匹配语法(词法单元类型.标识符).值;
            
            // 检查是否有构造函数参数
            if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.左圆括号)
            {
                var 参数列表 = new List<表达式节点>();
                
                匹配语法(词法单元类型.左圆括号);
                
                // 解析参数列表
                while (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 != 词法单元类型.右圆括号)
                {
                    var 参数 = 解析表达式();
                    参数列表.Add(参数);
                    
                    if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.逗号)
                    {
                        匹配语法(词法单元类型.逗号);
                    }
                }
                
                匹配语法(词法单元类型.右圆括号);
                
                // 返回方法调用表达式（模拟new操作）
                return new 方法调用表达式节点(new 标识符表达式节点($"new {类型名}"), 参数列表);
            }
            
            return new 标识符表达式节点($"new {类型名}");
        }
        
        // 解析方法体
        private 方法体节点 解析方法体()
        {
            var 语句列表 = new List<语句节点>();
            
            if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.左大括号)
            {
                this.当前位置++; // 跳过左大括号
                
                // 解析直到遇到右大括号
                while (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 != 词法单元类型.右大括号)
                {
                    var 语句 = 解析语句();
                    if (语句 != null)
                    {
                        语句列表.Add(语句);
                    }
                }
                
                if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.右大括号)
                {
                    this.当前位置++; // 跳过右大括号
                }
            }
            
            return new 方法体节点(语句列表);
        }
        
        // 解析语句
        private 语句节点? 解析语句()
        {
            if (this.当前位置 >= this.词法单元列表.Count)
                return null;
                
            // 跳过分号
            if (当前词法单元.类型 == 词法单元类型.分号)
            {
                this.当前位置++;
                return null;
            }
            
            // 解析返回语句
            if (当前词法单元.类型 == 词法单元类型.返回)
            {
                this.当前位置++; // 跳过返回关键字
                var 表达式 = 解析表达式();
                return new 返回语句节点(表达式);
            }
            
            // 解析变量声明
            if (当前词法单元.类型 == 词法单元类型.变量)
            {
                return 解析变量声明语句();
            }
            
            // 解析如果语句
            if (当前词法单元.类型 == 词法单元类型.如果)
            {
                return 解析如果语句();
            }
            
            // 解析赋值语句
            if (当前词法单元.类型 == 词法单元类型.标识符)
            {
                var 标识符 = 当前词法单元.值;
                this.当前位置++; // 跳过标识符
                
                // 检查是否是属性访问
                if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.点号)
                {
                    // 解析属性访问
                    var 属性访问 = 解析属性访问表达式(标识符);
                    
                    if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.等号)
                    {
                        this.当前位置++; // 跳过等号
                        var 表达式 = 解析表达式();
                        return new 赋值语句节点(属性访问, 表达式);
                    }
                    else
                    {
                        // 不是赋值语句，回退
                        this.当前位置--;
                    }
                }
                else if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.等号)
                {
                    this.当前位置++; // 跳过等号
                    var 表达式 = 解析表达式();
                    return new 赋值语句节点(标识符, 表达式);
                }
                else
                {
                    // 不是赋值语句，回退
                    this.当前位置--;
                }
            }
            
            // 跳过不支持的语句
            Console.WriteLine($"警告: 跳过不支持的语句: {当前词法单元.值}");
            this.当前位置++;
            return null;
        }
        
        // 解析如果语句
        private 语句节点 解析如果语句()
        {
            匹配语法(词法单元类型.如果);
            
            // 解析条件
            var 条件 = 解析表达式();
            
            // 解析then块
            if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.左大括号)
            {
                this.当前位置++; // 跳过左大括号
                
                var then语句列表 = new List<语句节点>();
                while (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 != 词法单元类型.右大括号)
                {
                    var 语句 = 解析语句();
                    if (语句 != null)
                    {
                        then语句列表.Add(语句);
                    }
                }
                
                匹配语法(词法单元类型.右大括号);
                
                // 检查是否有否则分支
                var else语句列表 = new List<语句节点>();
                if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.否则)
                {
                    匹配语法(词法单元类型.否则);
                    
                    // 解析else块
                    if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.左大括号)
                    {
                        this.当前位置++; // 跳过左大括号
                        
                        while (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 != 词法单元类型.右大括号)
                        {
                            var 语句 = 解析语句();
                            if (语句 != null)
                            {
                                else语句列表.Add(语句);
                            }
                        }
                        
                        匹配语法(词法单元类型.右大括号);
                    }
                }
                
                // 返回IfStatement节点
                return new 如果语句节点(条件, then语句列表, else语句列表.Count > 0 ? else语句列表 : null);
            }
            
            throw new Exception("如果语句格式错误");
        }
        
        // 解析变量声明语句
        private 语句节点 解析变量声明语句()
        {
            匹配语法(词法单元类型.变量);
            
            // 解析变量名
            string 变量名 = 匹配语法(词法单元类型.标识符).值;
            
            // 解析冒号
            匹配语法(词法单元类型.冒号);
            
            // 解析变量类型
            类型节点 变量类型 = 解析类型();
            
            // 检查是否有初始化表达式
            表达式节点? 初始化表达式 = null;
            if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.等号)
            {
                this.当前位置++; // 跳过等号
                初始化表达式 = 解析表达式();
            }
            
            // 检查是否有分号
            if (this.当前位置 < this.词法单元列表.Count && 当前词法单元.类型 == 词法单元类型.分号)
            {
                this.当前位置++;
            }
            else
            {
                throw new Exception("变量声明语句后期望分号");
            }
            
            return new 变量声明语句节点(变量名, 变量类型, 初始化表达式);
        }
        
        /// <summary>
        /// 获取收集的注释列表
        /// </summary>
        /// <returns>注释列表</returns>
        public List<string> 获取注释列表()
        {
            return 收集的注释列表;
        }
        
        /// <summary>
        /// 获取节点注释映射
        /// </summary>
        /// <returns>节点注释映射</returns>
        public Dictionary<string, List<string>> 获取节点注释映射()
        {
            return 节点注释映射;
        }
        
        /// <summary>
        /// 获取属性注释映射
        /// </summary>
        /// <returns>属性注释映射</returns>
        public Dictionary<string, List<string>> 获取属性注释映射()
        {
            return 属性注释映射;
        }
        
        /// <summary>
        /// 获取方法注释映射
        /// </summary>
        /// <returns>方法注释映射</returns>
        public Dictionary<string, List<string>> 获取方法注释映射()
        {
            return 方法注释映射;
        }
    }
}
